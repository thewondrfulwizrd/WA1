<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Convert StatCan 17100005 → observed JSON</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
      button { padding: 10px 14px; cursor: pointer; }
      pre { background: #f6f8fa; padding: 12px; border-radius: 8px; overflow: auto; }
      code { background: #f6f8fa; padding: 2px 6px; border-radius: 6px; }
    </style>
  </head>
  <body>
    <h1>Convert 17100005.csv → observed (2000–2025)</h1>
    <p>Reads <code>/data/17100005.csv</code> and downloads a JSON file.</p>
    <button id="run">Run conversion</button>
    <pre id="log"></pre>

    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script>
      const logEl = document.getElementById("log");
      const log = (msg) => (logEl.textContent += msg + "\n");

      function downloadJSON(filename, obj) {
        const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      // Normalize strings coming from CSV cells:
      // - convert null/undefined to ""
      // - replace NBSP with regular space
      // - trim
      // - collapse repeated whitespace
      function norm(v) {
        return String(v ?? "")
          .replace(/\u00A0/g, " ")
          .trim()
          .replace(/\s+/g, " ");
      }

      const START_YEAR = 2000;
      const LAST_OBSERVED_YEAR = 2025;

      document.getElementById("run").onclick = async () => {
        logEl.textContent = "";

        log("Fetching /data/17100005.csv ...");
        const res = await fetch("./data/17100005.csv", { cache: "no-store" });
        if (!res.ok) {
          log(`Failed: HTTP ${res.status}`);
          throw new Error(`Failed to fetch CSV: HTTP ${res.status}`);
        }
        const csvText = await res.text();
        log(`Fetched ${csvText.length.toLocaleString()} characters`);

        log("Parsing CSV (PapaParse) ...");
        const parsed = Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,

          // Strip UTF-8 BOM if present on the first header cell (your CSV starts with ﻿"REF_DATE"). 
          transformHeader: (h) => (h || "").replace(/^\uFEFF/, "").trim()
        });

        if (parsed.errors?.length) {
          log("Parse warnings/errors (first 5):");
          parsed.errors.slice(0, 5).forEach(e => log(JSON.stringify(e)));
        }

        const rows = parsed.data || [];
        log(`Total parsed rows: ${rows.length.toLocaleString()}`);

        // Column names (after transformHeader)
        const YEAR_COL = "REF_DATE";
        const GEO_COL = "GEO";
        const GENDER_COL = "Gender";
        const AGE_COL = "Age group";
        const VAL_COL = "VALUE";

        // Debug: detected columns
        const firstRow = rows[0] || {};
        log("Detected columns (from first row):");
        log(Object.keys(firstRow).join(", ") || "(none)");

        // Debug: show distinct Gender/Age group values (first 50 of each)
        const genders = Array.from(new Set(rows.map(r => norm(r[GENDER_COL])))).filter(Boolean).sort();
        const agesAll = Array.from(new Set(rows.map(r => norm(r[AGE_COL])))).filter(Boolean).sort();

        log(`Distinct Gender values (${genders.length}): ${genders.slice(0, 50).join(" | ")}${genders.length > 50 ? " | ..." : ""}`);
        log(`Distinct Age group values (${agesAll.length}): ${agesAll.slice(0, 50).join(" | ")}${agesAll.length > 50 ? " | ..." : ""}`);

        // Accept a few possible labels just in case
        const MALE_LABELS = new Set(["Men", "Males", "Male"]);
        const FEMALE_LABELS = new Set(["Women", "Females", "Female"]);

        // Filter rows we need for pyramid: Canada, 2000–2025, Men/Women, and exclude "All ages"
        const slice = rows.filter(r => {
          const year = Number(norm(r[YEAR_COL]));
          const geo = norm(r[GEO_COL]);
          const gender = norm(r[GENDER_COL]);
          const age = norm(r[AGE_COL]);
          const valueRaw = norm(r[VAL_COL]);

          return (
            geo === "Canada" &&
            Number.isFinite(year) &&
            year >= START_YEAR &&
            year <= LAST_OBSERVED_YEAR &&
            (MALE_LABELS.has(gender) || FEMALE_LABELS.has(gender)) &&
            age !== "All ages" &&
            valueRaw !== ""
          );
        });

        log(`Rows after filter: ${slice.length.toLocaleString()}`);

        // If still zero, show a couple of "Men"/"Women" candidates so we can see why
        if (slice.length === 0) {
          const candidates = rows
            .filter(r => ["Men","Women","Males","Females"].includes(norm(r[GENDER_COL])))
            .slice(0, 5)
            .map(r => ({
              REF_DATE: norm(r[YEAR_COL]),
              GEO: norm(r[GEO_COL]),
              Gender: norm(r[GENDER_COL]),
              "Age group": norm(r[AGE_COL]),
              VALUE: norm(r[VAL_COL])
            }));

          log("Sample rows where Gender looks like Men/Women (first 5):");
          log(JSON.stringify(candidates, null, 2));

          throw new Error("Filter produced 0 rows. See debug output above.");
        }

        // Collect age groups in first-seen order within the filtered slice
        const ages = [];
        const ageToIndex = new Map();
        for (const r of slice) {
          const a = norm(r[AGE_COL]);
          if (!ageToIndex.has(a)) {
            ageToIndex.set(a, ages.length);
            ages.push(a);
          }
        }
        log(`Age groups found (in output order): ${ages.length}`);

        // Initialize observed structure
        const observed = {};
        for (let y = START_YEAR; y <= LAST_OBSERVED_YEAR; y++) {
          observed[String(y)] = {
            male: Array(ages.length).fill(null),
            female: Array(ages.length).fill(null)
          };
        }

        // Fill values
        for (const r of slice) {
          const year = String(Number(norm(r[YEAR_COL])));
          const age = norm(r[AGE_COL]);
          const gender = norm(r[GENDER_COL]);
          const value = Number(norm(r[VAL_COL]));
          const idx = ageToIndex.get(age);

          if (idx == null || !Number.isFinite(value)) continue;

          if (MALE_LABELS.has(gender)) observed[year].male[idx] = value;
          if (FEMALE_LABELS.has(gender)) observed[year].female[idx] = value;
        }

        // Sanity check: missing cells
        let missing = 0;
        for (let y = START_YEAR; y <= LAST_OBSERVED_YEAR; y++) {
          const yr = String(y);
          missing += observed[yr].male.filter(v => v == null).length;
          missing += observed[yr].female.filter(v => v == null).length;
        }
        log(`Missing cells (should be 0): ${missing}`);

        const out = {
          source: "Statistics Canada table 17-10-0005-01 (PID 17100005)",
          geography: "Canada",
          yearsObserved: Array.from({ length: (LAST_OBSERVED_YEAR - START_YEAR + 1) }, (_, i) => START_YEAR + i),
          lastObservedYear: LAST_OBSERVED_YEAR,
          ages,
          observed
        };

        const filename = `canada_age_sex_observed_${START_YEAR}_${LAST_OBSERVED_YEAR}.json`;
        downloadJSON(filename, out);
        log(`Done — JSON downloaded: ${filename}`);
      };
    </script>
  </body>
</html>
